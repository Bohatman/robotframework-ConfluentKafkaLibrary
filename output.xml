<?xml version="1.0" encoding="UTF-8"?>
<robot generator="Robot 4.1.3 (Python 3.8.10 on linux)" generated="20220206 19:23:36.586" rpa="false" schemaversion="2">
<suite id="s1" name="Examples" source="/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples">
<suite id="s1-s1" name="Test" source="/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples/test.robot">
<kw name="Starting Test" type="SETUP">
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${TEST_TOPIC}</arg>
<arg>test</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:37.193" level="INFO">${TEST_TOPIC} = test</msg>
<status status="PASS" starttime="20220206 19:23:37.192" endtime="20220206 19:23:37.193"/>
</kw>
<kw name="Start Consumer Threaded" library="ConfluentKafkaLibrary">
<var>${thread}</var>
<arg>topics=${TEST_TOPIC}</arg>
<doc>Run consumer in daemon thread and store data from topics. To read and work with this
   collected data use keyword `Get Messages From Thread`.
   Could be used at the Test setup or in each test.
   This is useful when you are reading always the same topics and you don't want to create
   consumer in each test to poll data. You can create as many consumers in the Test setup
   as you want and then in test just read data with `Get Messages From Thread` keyword.
- ``topics`` (list): List of topics for subscription.
- ``group_id`` (str or uuid.uuid4() if not set) : name of the consumer group to join for
    dynamic partition assignment (if enabled), and to use for fetching and
    committing offsets. If None, unique string is generated  (via uuid.uuid4())
    and offset commits are disabled. Default: `None`.</doc>
<msg timestamp="20220206 19:23:47.209" level="INFO">${thread} = &lt;GetMessagesThread(Thread-1, started daemon 139783570827008)&gt;</msg>
<status status="PASS" starttime="20220206 19:23:37.193" endtime="20220206 19:23:47.209"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${MAIN_THREAD}</arg>
<arg>${thread}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:47.211" level="INFO">${MAIN_THREAD} = &lt;GetMessagesThread(Thread-1, started daemon 139783570827008)&gt;</msg>
<status status="PASS" starttime="20220206 19:23:47.209" endtime="20220206 19:23:47.211"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_group_id}</var>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:23:47.212" level="INFO">${producer_group_id} = 64e7f938-921a-4b00-9ab4-d2eb9e81e4cb</msg>
<status status="PASS" starttime="20220206 19:23:47.211" endtime="20220206 19:23:47.212"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${PRODUCER_ID}</arg>
<arg>${producer_group_id}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:47.215" level="INFO">${PRODUCER_ID} = 64e7f938-921a-4b00-9ab4-d2eb9e81e4cb</msg>
<status status="PASS" starttime="20220206 19:23:47.212" endtime="20220206 19:23:47.217"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${P_ID}</arg>
<arg>${0}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:47.218" level="INFO">${P_ID} = 0</msg>
<status status="PASS" starttime="20220206 19:23:47.217" endtime="20220206 19:23:47.218"/>
</kw>
<kw name="Prepare Data">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.219" endtime="20220206 19:23:47.219"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.219" endtime="20220206 19:23:47.220"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.220" endtime="20220206 19:23:47.220"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.220" endtime="20220206 19:23:47.221"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.221" endtime="20220206 19:23:47.221"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:47.222" endtime="20220206 19:23:47.222"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:47.324" level="INFO">${count} = 6</msg>
<status status="PASS" starttime="20220206 19:23:47.223" endtime="20220206 19:23:47.324"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:47.325" level="INFO">Reaming messages to be delivered: 6</msg>
<status status="PASS" starttime="20220206 19:23:47.324" endtime="20220206 19:23:47.325"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:47.325" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:47.326" level="FAIL">6 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:47.325" endtime="20220206 19:23:47.326"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:47.222" endtime="20220206 19:23:47.327"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:47.928" level="INFO">${count} = 6</msg>
<status status="PASS" starttime="20220206 19:23:47.827" endtime="20220206 19:23:47.928"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:47.929" level="INFO">Reaming messages to be delivered: 6</msg>
<status status="PASS" starttime="20220206 19:23:47.929" endtime="20220206 19:23:47.929"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:47.929" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:47.930" level="FAIL">6 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:47.929" endtime="20220206 19:23:47.930"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:47.827" endtime="20220206 19:23:47.930"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:48.533" level="INFO">${count} = 6</msg>
<status status="PASS" starttime="20220206 19:23:48.431" endtime="20220206 19:23:48.533"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:48.534" level="INFO">Reaming messages to be delivered: 6</msg>
<status status="PASS" starttime="20220206 19:23:48.533" endtime="20220206 19:23:48.534"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:48.534" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:48.534" level="FAIL">6 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:48.534" endtime="20220206 19:23:48.534"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:48.431" endtime="20220206 19:23:48.535"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:49.138" level="INFO">${count} = 6</msg>
<status status="PASS" starttime="20220206 19:23:49.036" endtime="20220206 19:23:49.138"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:49.138" level="INFO">Reaming messages to be delivered: 6</msg>
<status status="PASS" starttime="20220206 19:23:49.138" endtime="20220206 19:23:49.138"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:49.139" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:49.139" level="FAIL">6 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:49.138" endtime="20220206 19:23:49.139"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:49.035" endtime="20220206 19:23:49.140"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:49.641" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:49.641" endtime="20220206 19:23:49.641"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:49.642" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:49.641" endtime="20220206 19:23:49.642"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:49.642" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:49.642" endtime="20220206 19:23:49.642"/>
</kw>
<status status="PASS" starttime="20220206 19:23:49.640" endtime="20220206 19:23:49.642"/>
</kw>
<status status="PASS" starttime="20220206 19:23:47.222" endtime="20220206 19:23:49.642"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:23:50.643" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:23:49.642" endtime="20220206 19:23:50.643"/>
</kw>
<status status="PASS" starttime="20220206 19:23:47.218" endtime="20220206 19:23:50.643"/>
</kw>
<kw name="List Topics" library="ConfluentKafkaLibrary">
<var>${topics}</var>
<arg>${producer_group_id}</arg>
<doc>Request Metadata from cluster. Could be executed with consumer or producer group_id too.
- ``topic`` (str):  If specified, only request info about this topic, else return for all topics in cluster.
Default: `None`.
- ``group_id`` (str): *required* id of the created consumer or producer.</doc>
<msg timestamp="20220206 19:23:50.648" level="INFO">${topics} = {'__confluent.support.metrics': TopicMetadata(__confluent.support.metrics, 1 partitions), '_schemas': TopicMetadata(_schemas, 1 partitions), 'test': TopicMetadata(test, 1 partitions), '__consumer_offs...</msg>
<status status="PASS" starttime="20220206 19:23:50.643" endtime="20220206 19:23:50.648"/>
</kw>
<kw name="Get Topic Partitions" library="ConfluentKafkaLibrary">
<var>${partitions}</var>
<arg>${topics['${TEST_TOPIC}']}</arg>
<doc>Returns dictionary of all TopicPartitons in topic (topic.partitions).</doc>
<msg timestamp="20220206 19:23:50.649" level="INFO">${partitions} = {0: PartitionMetadata(0)}</msg>
<status status="PASS" starttime="20220206 19:23:50.648" endtime="20220206 19:23:50.649"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${partition_id}</var>
<arg>${partitions[0].id}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:50.650" level="INFO">${partition_id} = 0</msg>
<status status="PASS" starttime="20220206 19:23:50.649" endtime="20220206 19:23:50.650"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${P_ID}</arg>
<arg>${partition_id}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:50.651" level="INFO">${P_ID} = 0</msg>
<status status="PASS" starttime="20220206 19:23:50.650" endtime="20220206 19:23:50.651"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${partition_id}</arg>
<arg>${OFFSET_BEGINNING}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:23:50.651" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=-2,error=None}</msg>
<status status="PASS" starttime="20220206 19:23:50.651" endtime="20220206 19:23:50.651"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${data}</var>
<arg>Hello</arg>
<arg>World</arg>
<arg>{'test': 1}</arg>
<arg>{'test': 2}</arg>
<arg>{'test': 3}</arg>
<arg>{'test': 4}</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:23:50.651" level="INFO">${data} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:23:50.651" endtime="20220206 19:23:50.652"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${data}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:23:50.653" level="INFO">${TEST_DATA} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:23:50.652" endtime="20220206 19:23:50.653"/>
</kw>
<kw name="Prepare Data">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.653" endtime="20220206 19:23:50.653"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.654" endtime="20220206 19:23:50.654"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.654" endtime="20220206 19:23:50.655"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.655" endtime="20220206 19:23:50.655"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.655" endtime="20220206 19:23:50.656"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:50.656" endtime="20220206 19:23:50.656"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:50.667" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:50.657" endtime="20220206 19:23:50.667"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:50.668" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:50.667" endtime="20220206 19:23:50.668"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:50.668" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:50.668" endtime="20220206 19:23:50.668"/>
</kw>
<status status="PASS" starttime="20220206 19:23:50.657" endtime="20220206 19:23:50.668"/>
</kw>
<status status="PASS" starttime="20220206 19:23:50.656" endtime="20220206 19:23:50.668"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:23:51.669" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:23:50.668" endtime="20220206 19:23:51.669"/>
</kw>
<status status="PASS" starttime="20220206 19:23:50.653" endtime="20220206 19:23:51.669"/>
</kw>
<status status="PASS" starttime="20220206 19:23:37.191" endtime="20220206 19:23:51.669"/>
</kw>
<test id="s1-s1-t1" name="Verify Topics">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<arg>auto_offset_reset=earliest</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:51.672" level="INFO">${group_id} = 5aadab05-c9b0-49fc-8a92-c5afc4126c25</msg>
<status status="PASS" starttime="20220206 19:23:51.670" endtime="20220206 19:23:51.672"/>
</kw>
<kw name="List Topics" library="ConfluentKafkaLibrary">
<var>${topics}</var>
<arg>${group_id}</arg>
<doc>Request Metadata from cluster. Could be executed with consumer or producer group_id too.
- ``topic`` (str):  If specified, only request info about this topic, else return for all topics in cluster.
Default: `None`.
- ``group_id`` (str): *required* id of the created consumer or producer.</doc>
<msg timestamp="20220206 19:23:51.679" level="INFO">${topics} = {'__confluent.support.metrics': TopicMetadata(__confluent.support.metrics, 1 partitions), '_schemas': TopicMetadata(_schemas, 1 partitions), 'test': TopicMetadata(test, 1 partitions), '__consumer_offs...</msg>
<status status="PASS" starttime="20220206 19:23:51.672" endtime="20220206 19:23:51.679"/>
</kw>
<kw name="Dictionary Should Contain Key" library="Collections">
<arg>${topics}</arg>
<arg>${TEST_TOPIC}</arg>
<doc>Fails if ``key`` is not found from ``dictionary``.</doc>
<status status="PASS" starttime="20220206 19:23:51.679" endtime="20220206 19:23:51.679"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary" type="TEARDOWN">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:23:51.679" endtime="20220206 19:23:51.681"/>
</kw>
<status status="PASS" starttime="20220206 19:23:51.669" endtime="20220206 19:23:51.681"/>
</test>
<test id="s1-s1-t2" name="Basic Consumer">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<arg>auto_offset_reset=earliest</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:51.684" level="INFO">${group_id} = b93e7c28-1750-4db7-be35-19afae5197b7</msg>
<status status="PASS" starttime="20220206 19:23:51.683" endtime="20220206 19:23:51.684"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>topics=${TEST_TOPIC}</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:23:51.684" endtime="20220206 19:23:51.685"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=3</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:23:51.805" level="INFO">${messages} = ['Hello', 'World', "{'test': 1}"]</msg>
<status status="PASS" starttime="20220206 19:23:51.685" endtime="20220206 19:23:51.805"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${data}</var>
<arg>Hello</arg>
<arg>World</arg>
<arg>{'test': 1}</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:23:51.805" level="INFO">${data} = ['Hello', 'World', "{'test': 1}"]</msg>
<status status="PASS" starttime="20220206 19:23:51.805" endtime="20220206 19:23:51.805"/>
</kw>
<kw name="Lists Should Be Equal" library="Collections">
<arg>${messages}</arg>
<arg>${data}</arg>
<doc>Fails if given lists are unequal.</doc>
<status status="PASS" starttime="20220206 19:23:51.806" endtime="20220206 19:23:51.806"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:23:51.806" endtime="20220206 19:23:51.807"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:23:51.807" endtime="20220206 19:23:51.825"/>
</kw>
<status status="PASS" starttime="20220206 19:23:51.806" endtime="20220206 19:23:51.826"/>
</kw>
<status status="PASS" starttime="20220206 19:23:51.682" endtime="20220206 19:23:51.826"/>
</test>
<test id="s1-s1-t3" name="Produce Without Value">
<kw name="Set Variable" library="BuiltIn">
<var>${topic_name}</var>
<arg>topicwithoutvaluee</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:51.827" level="INFO">${topic_name} = topicwithoutvaluee</msg>
<status status="PASS" starttime="20220206 19:23:51.827" endtime="20220206 19:23:51.827"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${topic_name}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:51.827" endtime="20220206 19:23:51.828"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:51.930" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:23:51.829" endtime="20220206 19:23:51.930"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:51.931" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:23:51.930" endtime="20220206 19:23:51.931"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:51.931" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:51.931" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:51.931" endtime="20220206 19:23:51.932"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:51.828" endtime="20220206 19:23:51.932"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:52.535" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:23:52.433" endtime="20220206 19:23:52.535"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:52.535" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:23:52.535" endtime="20220206 19:23:52.535"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:52.536" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:52.536" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:52.536" endtime="20220206 19:23:52.536"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:52.432" endtime="20220206 19:23:52.537"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:53.140" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:23:53.038" endtime="20220206 19:23:53.140"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:53.140" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:23:53.140" endtime="20220206 19:23:53.140"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:53.141" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:23:53.141" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:23:53.140" endtime="20220206 19:23:53.141"/>
</kw>
<status status="FAIL" starttime="20220206 19:23:53.037" endtime="20220206 19:23:53.141"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:53.643" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:53.642" endtime="20220206 19:23:53.643"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:53.643" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:53.643" endtime="20220206 19:23:53.643"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:53.644" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:53.643" endtime="20220206 19:23:53.644"/>
</kw>
<status status="PASS" starttime="20220206 19:23:53.642" endtime="20220206 19:23:53.644"/>
</kw>
<status status="PASS" starttime="20220206 19:23:51.828" endtime="20220206 19:23:53.644"/>
</kw>
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<arg>auto_offset_reset=earliest</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:53.645" level="INFO">${group_id} = 158d0065-614c-4f55-8ba8-278ce22d6a2c</msg>
<status status="PASS" starttime="20220206 19:23:53.644" endtime="20220206 19:23:53.645"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>topics=${topic_name}</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:23:53.646" endtime="20220206 19:23:53.647"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=1</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:23:53.767" level="INFO">${messages} = [None]</msg>
<status status="PASS" starttime="20220206 19:23:53.647" endtime="20220206 19:23:53.767"/>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<arg>${messages}</arg>
<arg>[None]</arg>
<doc>Fails if objects are unequal after converting them to strings.</doc>
<msg timestamp="20220206 19:23:53.768" level="INFO">Argument types are:
&lt;class 'list'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:53.767" endtime="20220206 19:23:53.768"/>
</kw>
<status status="PASS" starttime="20220206 19:23:51.827" endtime="20220206 19:23:53.768"/>
</test>
<test id="s1-s1-t4" name="Verify Position">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:53.770" level="INFO">${group_id} = 2a6e559c-f267-4be3-b1c7-be0c371b2f8a</msg>
<status status="PASS" starttime="20220206 19:23:53.769" endtime="20220206 19:23:53.770"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${P_ID}</arg>
<arg>${OFFSET_END}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:23:53.770" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=-1,error=None}</msg>
<status status="PASS" starttime="20220206 19:23:53.770" endtime="20220206 19:23:53.770"/>
</kw>
<kw name="Assign To Topic Partition" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<arg>${tp}</arg>
<doc>Assign a list of TopicPartitions.</doc>
<status status="PASS" starttime="20220206 19:23:53.770" endtime="20220206 19:23:53.774"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>5sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:23:58.775" level="INFO">Slept 5 seconds</msg>
<status status="PASS" starttime="20220206 19:23:53.774" endtime="20220206 19:23:58.775"/>
</kw>
<kw name="Get Position" library="ConfluentKafkaLibrary">
<var>${position}</var>
<arg>group_id=${group_id}</arg>
<arg>topic_partitions=${tp}</arg>
<doc>Retrieve current positions (offsets) for the list of partitions.</doc>
<msg timestamp="20220206 19:23:58.776" level="INFO">${position} = [TopicPartition{topic=test,partition=0,offset=-1001,error=None}]</msg>
<status status="PASS" starttime="20220206 19:23:58.775" endtime="20220206 19:23:58.776"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${position_before}</var>
<arg>${position[0].offset}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:58.776" level="INFO">${position_before} = -1001</msg>
<status status="PASS" starttime="20220206 19:23:58.776" endtime="20220206 19:23:58.776"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Dummy</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.777" endtime="20220206 19:23:58.777"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:58.781" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:58.778" endtime="20220206 19:23:58.781"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:58.782" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:58.781" endtime="20220206 19:23:58.782"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:58.782" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:58.782" endtime="20220206 19:23:58.782"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.777" endtime="20220206 19:23:58.782"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.777" endtime="20220206 19:23:58.782"/>
</kw>
<kw name="Get Position" library="ConfluentKafkaLibrary">
<var>${position}</var>
<arg>group_id=${group_id}</arg>
<arg>topic_partitions=${tp}</arg>
<doc>Retrieve current positions (offsets) for the list of partitions.</doc>
<msg timestamp="20220206 19:23:58.783" level="INFO">${position} = [TopicPartition{topic=test,partition=0,offset=-1001,error=None}]</msg>
<status status="PASS" starttime="20220206 19:23:58.782" endtime="20220206 19:23:58.783"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${position_after_produce}</var>
<arg>${position[0].offset}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:58.783" level="INFO">${position_after_produce} = -1001</msg>
<status status="PASS" starttime="20220206 19:23:58.783" endtime="20220206 19:23:58.783"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${position_before}</arg>
<arg>${position_after_produce}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<status status="PASS" starttime="20220206 19:23:58.784" endtime="20220206 19:23:58.784"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=1</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:23:58.784" level="INFO">${messages} = ['Dummy']</msg>
<status status="PASS" starttime="20220206 19:23:58.784" endtime="20220206 19:23:58.785"/>
</kw>
<kw name="Get Position" library="ConfluentKafkaLibrary">
<var>${position}</var>
<arg>group_id=${group_id}</arg>
<arg>topic_partitions=${tp}</arg>
<doc>Retrieve current positions (offsets) for the list of partitions.</doc>
<msg timestamp="20220206 19:23:58.786" level="INFO">${position} = [TopicPartition{topic=test,partition=0,offset=13,error=None}]</msg>
<status status="PASS" starttime="20220206 19:23:58.785" endtime="20220206 19:23:58.786"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${position_after_poll_1}</var>
<arg>${position[0].offset}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:58.787" level="INFO">${position_after_poll_1} = 13</msg>
<status status="PASS" starttime="20220206 19:23:58.786" endtime="20220206 19:23:58.787"/>
</kw>
<kw name="Should Not Be Equal As Integers" library="BuiltIn">
<arg>${position_after_poll_1}</arg>
<arg>${position_after_produce}</arg>
<doc>Fails if objects are equal after converting them to integers.</doc>
<status status="PASS" starttime="20220206 19:23:58.787" endtime="20220206 19:23:58.787"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Dummy</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.787" endtime="20220206 19:23:58.787"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:58.791" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:58.788" endtime="20220206 19:23:58.792"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:58.792" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:58.792" endtime="20220206 19:23:58.792"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:58.792" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:58.792" endtime="20220206 19:23:58.792"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.788" endtime="20220206 19:23:58.792"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.788" endtime="20220206 19:23:58.792"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=1</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:23:58.793" level="INFO">${messages} = ['Dummy']</msg>
<status status="PASS" starttime="20220206 19:23:58.793" endtime="20220206 19:23:58.793"/>
</kw>
<kw name="Get Position" library="ConfluentKafkaLibrary">
<var>${position}</var>
<arg>group_id=${group_id}</arg>
<arg>topic_partitions=${tp}</arg>
<doc>Retrieve current positions (offsets) for the list of partitions.</doc>
<msg timestamp="20220206 19:23:58.794" level="INFO">${position} = [TopicPartition{topic=test,partition=0,offset=14,error=None}]</msg>
<status status="PASS" starttime="20220206 19:23:58.793" endtime="20220206 19:23:58.794"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${position_after_poll_2}</var>
<arg>${position[0].offset}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:23:58.794" level="INFO">${position_after_poll_2} = 14</msg>
<status status="PASS" starttime="20220206 19:23:58.794" endtime="20220206 19:23:58.795"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${position_after_poll_1 + 1}</arg>
<arg>${position_after_poll_2}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<status status="PASS" starttime="20220206 19:23:58.795" endtime="20220206 19:23:58.795"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:23:58.796" endtime="20220206 19:23:58.796"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:23:58.796" endtime="20220206 19:23:58.799"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.796" endtime="20220206 19:23:58.799"/>
</kw>
<status status="PASS" starttime="20220206 19:23:53.768" endtime="20220206 19:23:58.799"/>
</test>
<test id="s1-s1-t5" name="Consumer With Assignment To Last Message After Get Of Watermark Offsets">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:58.801" level="INFO">${group_id} = add999a1-9ec5-47c6-b382-823eca06c5e5</msg>
<status status="PASS" starttime="20220206 19:23:58.800" endtime="20220206 19:23:58.801"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${P_ID}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:23:58.801" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=-1001,error=None}</msg>
<status status="PASS" starttime="20220206 19:23:58.801" endtime="20220206 19:23:58.801"/>
</kw>
<kw name="Get Watermark Offsets" library="ConfluentKafkaLibrary">
<var>${offset}</var>
<arg>${group_id}</arg>
<arg>${tp}</arg>
<doc>Retrieve low and high offsets for partition.</doc>
<msg timestamp="20220206 19:23:58.816" level="INFO">${offset} = (0, 14)</msg>
<status status="PASS" starttime="20220206 19:23:58.801" endtime="20220206 19:23:58.816"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${P_ID}</arg>
<arg>${offset[1]}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:23:58.817" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=14,error=None}</msg>
<status status="PASS" starttime="20220206 19:23:58.816" endtime="20220206 19:23:58.817"/>
</kw>
<kw name="Assign To Topic Partition" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<arg>${tp}</arg>
<doc>Assign a list of TopicPartitions.</doc>
<status status="PASS" starttime="20220206 19:23:58.817" endtime="20220206 19:23:58.818"/>
</kw>
<kw name="Prepare Data">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.818" endtime="20220206 19:23:58.819"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.819" endtime="20220206 19:23:58.819"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.819" endtime="20220206 19:23:58.820"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.820" endtime="20220206 19:23:58.820"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.821" endtime="20220206 19:23:58.821"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:23:58.821" endtime="20220206 19:23:58.822"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:23:58.825" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:23:58.822" endtime="20220206 19:23:58.825"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:23:58.825" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:23:58.825" endtime="20220206 19:23:58.825"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:23:58.826" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:23:58.825" endtime="20220206 19:23:58.826"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.822" endtime="20220206 19:23:58.826"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.822" endtime="20220206 19:23:58.826"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:23:59.827" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:23:58.826" endtime="20220206 19:23:59.827"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.818" endtime="20220206 19:23:59.827"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=6</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:23:59.828" level="INFO">${messages} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:23:59.827" endtime="20220206 19:23:59.828"/>
</kw>
<kw name="Lists Should Be Equal" library="Collections">
<arg>${TEST_DATA}</arg>
<arg>${messages}</arg>
<doc>Fails if given lists are unequal.</doc>
<status status="PASS" starttime="20220206 19:23:59.828" endtime="20220206 19:23:59.828"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:23:59.829" endtime="20220206 19:23:59.829"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:23:59.829" endtime="20220206 19:23:59.833"/>
</kw>
<status status="PASS" starttime="20220206 19:23:59.828" endtime="20220206 19:23:59.833"/>
</kw>
<status status="PASS" starttime="20220206 19:23:58.800" endtime="20220206 19:23:59.833"/>
</test>
<test id="s1-s1-t6" name="Consumer With Assignment To OFFSET_END">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:23:59.836" level="INFO">${group_id} = 6c6939e4-2603-4161-a8d7-82fa21fdf1aa</msg>
<status status="PASS" starttime="20220206 19:23:59.835" endtime="20220206 19:23:59.836"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${P_ID}</arg>
<arg>${OFFSET_END}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:23:59.837" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=-1,error=None}</msg>
<status status="PASS" starttime="20220206 19:23:59.836" endtime="20220206 19:23:59.837"/>
</kw>
<kw name="Assign To Topic Partition" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<arg>${tp}</arg>
<doc>Assign a list of TopicPartitions.</doc>
<status status="PASS" starttime="20220206 19:23:59.837" endtime="20220206 19:23:59.837"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>5sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:04.839" level="INFO">Slept 5 seconds</msg>
<status status="PASS" starttime="20220206 19:23:59.837" endtime="20220206 19:24:04.839"/>
</kw>
<kw name="Prepare Data">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.840" endtime="20220206 19:24:04.841"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.841" endtime="20220206 19:24:04.841"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.841" endtime="20220206 19:24:04.842"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.842" endtime="20220206 19:24:04.842"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.842" endtime="20220206 19:24:04.843"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:04.843" endtime="20220206 19:24:04.843"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:04.848" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:04.846" endtime="20220206 19:24:04.848"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:04.849" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:04.849" endtime="20220206 19:24:04.849"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:04.849" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:04.849" endtime="20220206 19:24:04.849"/>
</kw>
<status status="PASS" starttime="20220206 19:24:04.844" endtime="20220206 19:24:04.849"/>
</kw>
<status status="PASS" starttime="20220206 19:24:04.844" endtime="20220206 19:24:04.849"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:05.850" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:04.849" endtime="20220206 19:24:05.850"/>
</kw>
<status status="PASS" starttime="20220206 19:24:04.840" endtime="20220206 19:24:05.850"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>poll_attempts=30</arg>
<arg>max_records=6</arg>
<arg>timeout=5</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:05.851" level="INFO">${messages} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:24:05.850" endtime="20220206 19:24:05.851"/>
</kw>
<kw name="Lists Should Be Equal" library="Collections">
<arg>${TEST_DATA}</arg>
<arg>${messages}</arg>
<doc>Fails if given lists are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:05.851" endtime="20220206 19:24:05.851"/>
</kw>
<kw name="Unassign Teardown" type="TEARDOWN">
<arg>${group_id}</arg>
<kw name="Unassign" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<status status="PASS" starttime="20220206 19:24:05.852" endtime="20220206 19:24:05.852"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:24:05.852" endtime="20220206 19:24:05.856"/>
</kw>
<status status="PASS" starttime="20220206 19:24:05.852" endtime="20220206 19:24:05.856"/>
</kw>
<status status="PASS" starttime="20220206 19:23:59.835" endtime="20220206 19:24:05.856"/>
</test>
<test id="s1-s1-t7" name="Verify Test And Threaded Consumer">
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="SETUP">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:05.857" endtime="20220206 19:24:05.857"/>
</kw>
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:24:05.858" level="INFO">${group_id} = d94ed6b8-27f0-482a-9db6-d838b67318b9</msg>
<status status="PASS" starttime="20220206 19:24:05.857" endtime="20220206 19:24:05.858"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>topics=${TEST_TOPIC}</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:24:05.858" endtime="20220206 19:24:05.858"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:15.860" level="INFO">${messages} = []</msg>
<status status="PASS" starttime="20220206 19:24:05.858" endtime="20220206 19:24:15.860"/>
</kw>
<kw name="Prepare Data">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.861" endtime="20220206 19:24:15.861"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.861" endtime="20220206 19:24:15.862"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.862" endtime="20220206 19:24:15.862"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.862" endtime="20220206 19:24:15.863"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.863" endtime="20220206 19:24:15.863"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:15.864" endtime="20220206 19:24:15.864"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:15.869" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:15.865" endtime="20220206 19:24:15.869"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:15.869" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:15.869" endtime="20220206 19:24:15.869"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:15.869" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:15.869" endtime="20220206 19:24:15.869"/>
</kw>
<status status="PASS" starttime="20220206 19:24:15.864" endtime="20220206 19:24:15.869"/>
</kw>
<status status="PASS" starttime="20220206 19:24:15.864" endtime="20220206 19:24:15.869"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:16.870" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:15.870" endtime="20220206 19:24:16.870"/>
</kw>
<status status="PASS" starttime="20220206 19:24:15.860" endtime="20220206 19:24:16.870"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages}</var>
<arg>${MAIN_THREAD}</arg>
<arg>decode_format=utf-8</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:16.871" level="INFO">${thread_messages} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:24:16.871" endtime="20220206 19:24:16.871"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${group_id}</arg>
<arg>max_records=6</arg>
<arg>decode_format=utf8</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:16.872" level="INFO">${messages} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:24:16.872" endtime="20220206 19:24:16.872"/>
</kw>
<kw name="Lists Should Be Equal" library="Collections">
<arg>${thread_messages}</arg>
<arg>${messages}</arg>
<doc>Fails if given lists are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:16.872" endtime="20220206 19:24:16.872"/>
</kw>
<kw name="Run Keywords" library="BuiltIn" type="TEARDOWN">
<arg>Basic Teardown</arg>
<arg>${group_id}</arg>
<arg>AND</arg>
<arg>Clear Messages From Thread</arg>
<arg>${MAIN_THREAD}</arg>
<doc>Executes all the given keywords in a sequence.</doc>
<kw name="Basic Teardown">
<arg>${group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:24:16.887" endtime="20220206 19:24:16.887"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:24:16.887" endtime="20220206 19:24:16.893"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.873" endtime="20220206 19:24:16.893"/>
</kw>
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:16.893" endtime="20220206 19:24:16.893"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.873" endtime="20220206 19:24:16.893"/>
</kw>
<status status="PASS" starttime="20220206 19:24:05.857" endtime="20220206 19:24:16.893"/>
</test>
<test id="s1-s1-t8" name="Verify Clean Of Threaded Consumer Messages">
<kw name="Prepare Data" type="SETUP">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.894" endtime="20220206 19:24:16.895"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.895" endtime="20220206 19:24:16.895"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.895" endtime="20220206 19:24:16.896"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.896" endtime="20220206 19:24:16.896"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.896" endtime="20220206 19:24:16.897"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:16.897" endtime="20220206 19:24:16.897"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:16.901" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:16.898" endtime="20220206 19:24:16.901"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:16.901" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:16.901" endtime="20220206 19:24:16.901"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:16.901" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:16.901" endtime="20220206 19:24:16.901"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.898" endtime="20220206 19:24:16.901"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.897" endtime="20220206 19:24:16.901"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:17.902" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:16.901" endtime="20220206 19:24:17.902"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.894" endtime="20220206 19:24:17.902"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages1}</var>
<arg>${MAIN_THREAD}</arg>
<arg>decode_format=utf-8</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:17.903" level="INFO">${thread_messages1} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:24:17.902" endtime="20220206 19:24:17.903"/>
</kw>
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:17.903" endtime="20220206 19:24:17.903"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages2}</var>
<arg>${MAIN_THREAD}</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:17.904" level="INFO">${thread_messages2} = []</msg>
<status status="PASS" starttime="20220206 19:24:17.903" endtime="20220206 19:24:17.904"/>
</kw>
<kw name="Lists Should Be Equal" library="Collections">
<arg>${TEST_DATA}</arg>
<arg>${thread_messages1}</arg>
<doc>Fails if given lists are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:17.904" endtime="20220206 19:24:17.904"/>
</kw>
<kw name="Should Be Empty" library="BuiltIn">
<arg>${thread_messages2}</arg>
<doc>Verifies that the given item is empty.</doc>
<msg timestamp="20220206 19:24:17.905" level="INFO">Length is 0</msg>
<status status="PASS" starttime="20220206 19:24:17.904" endtime="20220206 19:24:17.905"/>
</kw>
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="TEARDOWN">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:17.905" endtime="20220206 19:24:17.905"/>
</kw>
<status status="PASS" starttime="20220206 19:24:16.893" endtime="20220206 19:24:17.905"/>
</test>
<test id="s1-s1-t9" name="Remove And Publish New Messages From Threaded Consumer">
<kw name="Prepare Data" type="SETUP">
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Hello</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.906" endtime="20220206 19:24:17.907"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=World</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.907" endtime="20220206 19:24:17.908"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 1}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.908" endtime="20220206 19:24:17.908"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 2}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.908" endtime="20220206 19:24:17.909"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 3}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.909" endtime="20220206 19:24:17.910"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value={'test': 4}</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:17.910" endtime="20220206 19:24:17.910"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:17.913" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:17.911" endtime="20220206 19:24:17.913"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:17.914" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:17.914" endtime="20220206 19:24:17.914"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:17.914" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:17.914" endtime="20220206 19:24:17.914"/>
</kw>
<status status="PASS" starttime="20220206 19:24:17.910" endtime="20220206 19:24:17.914"/>
</kw>
<status status="PASS" starttime="20220206 19:24:17.910" endtime="20220206 19:24:17.914"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:18.915" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:17.914" endtime="20220206 19:24:18.915"/>
</kw>
<status status="PASS" starttime="20220206 19:24:17.906" endtime="20220206 19:24:18.915"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages1}</var>
<arg>${MAIN_THREAD}</arg>
<arg>decode_format=utf-8</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:18.916" level="INFO">${thread_messages1} = ['Hello', 'World', "{'test': 1}", "{'test': 2}", "{'test': 3}", "{'test': 4}"]</msg>
<status status="PASS" starttime="20220206 19:24:18.915" endtime="20220206 19:24:18.916"/>
</kw>
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:18.916" endtime="20220206 19:24:18.916"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=After</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:18.917" endtime="20220206 19:24:18.917"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Clear</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:18.917" endtime="20220206 19:24:18.918"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:18.921" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:18.919" endtime="20220206 19:24:18.921"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:18.921" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:18.921" endtime="20220206 19:24:18.921"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:18.921" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:18.921" endtime="20220206 19:24:18.921"/>
</kw>
<status status="PASS" starttime="20220206 19:24:18.918" endtime="20220206 19:24:18.922"/>
</kw>
<status status="PASS" starttime="20220206 19:24:18.918" endtime="20220206 19:24:18.922"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:19.922" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:18.922" endtime="20220206 19:24:19.922"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages2}</var>
<arg>${MAIN_THREAD}</arg>
<arg>decode_format=utf-8</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:19.923" level="INFO">${thread_messages2} = ['After', 'Clear']</msg>
<status status="PASS" starttime="20220206 19:24:19.922" endtime="20220206 19:24:19.923"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${data}</var>
<arg>After</arg>
<arg>Clear</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:24:19.923" level="INFO">${data} = ['After', 'Clear']</msg>
<status status="PASS" starttime="20220206 19:24:19.923" endtime="20220206 19:24:19.923"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${data}</arg>
<arg>${thread_messages2}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:19.923" endtime="20220206 19:24:19.924"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${PRODUCER_ID}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=LAST</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:19.924" endtime="20220206 19:24:19.924"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${PRODUCER_ID}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${PRODUCER_ID}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:19.928" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:19.925" endtime="20220206 19:24:19.928"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:19.928" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:19.928" endtime="20220206 19:24:19.928"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:19.929" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:19.928" endtime="20220206 19:24:19.929"/>
</kw>
<status status="PASS" starttime="20220206 19:24:19.925" endtime="20220206 19:24:19.929"/>
</kw>
<status status="PASS" starttime="20220206 19:24:19.924" endtime="20220206 19:24:19.929"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:20.929" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:19.929" endtime="20220206 19:24:20.930"/>
</kw>
<kw name="Append To List" library="Collections">
<arg>${data}</arg>
<arg>LAST</arg>
<doc>Adds ``values`` to the end of ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:20.930" endtime="20220206 19:24:20.930"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages2}</var>
<arg>${MAIN_THREAD}</arg>
<arg>decode_format=utf-8</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:20.931" level="INFO">${thread_messages2} = ['After', 'Clear', 'LAST']</msg>
<status status="PASS" starttime="20220206 19:24:20.930" endtime="20220206 19:24:20.931"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${thread_messages1}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:20.931" endtime="20220206 19:24:20.931"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${data}</arg>
<arg>${thread_messages2}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:20.931" endtime="20220206 19:24:20.932"/>
</kw>
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="TEARDOWN">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:20.932" endtime="20220206 19:24:20.932"/>
</kw>
<status status="PASS" starttime="20220206 19:24:17.906" endtime="20220206 19:24:20.932"/>
</test>
<test id="s1-s1-t10" name="Purge Test">
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:24:20.933" level="INFO">${producer_id} = 2a278012-93bb-47be-9cc1-8fa9f25fbb42</msg>
<status status="PASS" starttime="20220206 19:24:20.933" endtime="20220206 19:24:20.933"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=After</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:20.934" endtime="20220206 19:24:20.935"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=${TEST_TOPIC}</arg>
<arg>value=Clear</arg>
<arg>partition=${P_ID}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:20.935" endtime="20220206 19:24:20.936"/>
</kw>
<kw name="Purge" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>in_queue=${False}</arg>
<doc>Purge messages currently handled by the producer instance.</doc>
<status status="PASS" starttime="20220206 19:24:20.936" endtime="20220206 19:24:20.936"/>
</kw>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<arg>timeout=${0}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:20.937" level="INFO">${count} = 2</msg>
<status status="PASS" starttime="20220206 19:24:20.936" endtime="20220206 19:24:20.937"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>2</arg>
<arg>${count}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:20.937" level="INFO">Argument types are:
&lt;type 'unicode'&gt;
&lt;class 'int'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:20.937" endtime="20220206 19:24:20.937"/>
</kw>
<kw name="Purge" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<doc>Purge messages currently handled by the producer instance.</doc>
<status status="PASS" starttime="20220206 19:24:20.937" endtime="20220206 19:24:20.938"/>
</kw>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<arg>timeout=${0}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:20.939" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:20.938" endtime="20220206 19:24:20.939"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>0</arg>
<arg>${count}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:20.939" level="INFO">Argument types are:
&lt;type 'unicode'&gt;
&lt;class 'int'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:20.939" endtime="20220206 19:24:20.939"/>
</kw>
<status status="PASS" starttime="20220206 19:24:20.933" endtime="20220206 19:24:20.939"/>
</test>
<test id="s1-s1-t11" name="Offsets Test">
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${group_id}</var>
<arg>enable.auto.offset.store=${False}</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:24:20.941" level="INFO">${group_id} = 5345453b-77f9-4516-86f1-83b4e9e11213</msg>
<status status="PASS" starttime="20220206 19:24:20.941" endtime="20220206 19:24:20.941"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>topics=${TEST_TOPIC}</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:24:20.941" endtime="20220206 19:24:20.942"/>
</kw>
<kw name="Create Topic Partition" library="ConfluentKafkaLibrary">
<var>${tp}</var>
<arg>${TEST_TOPIC}</arg>
<arg>${P_ID}</arg>
<arg>${OFFSET_BEGINNING}</arg>
<doc>Returns TopicPartiton object based on
https://docs.confluent.io/current/clients/confluent-kafka-python/#topicpartition</doc>
<msg timestamp="20220206 19:24:20.942" level="INFO">${tp} = TopicPartition{topic=test,partition=0,offset=-2,error=None}</msg>
<status status="PASS" starttime="20220206 19:24:20.942" endtime="20220206 19:24:20.942"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${offsets}</var>
<arg>${tp}</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:24:20.942" level="INFO">${offsets} = [TopicPartition{topic=test,partition=0,offset=-2,error=None}]</msg>
<status status="PASS" starttime="20220206 19:24:20.942" endtime="20220206 19:24:20.942"/>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<arg>KafkaException: *</arg>
<arg>Store Offsets</arg>
<arg>group_id=${group_id}</arg>
<arg>offsets=${offsets}</arg>
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<kw name="Store Offsets" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>offsets=${offsets}</arg>
<doc>Store offsets for a message or a list of offsets.</doc>
<msg timestamp="20220206 19:24:20.944" level="FAIL">KafkaException: KafkaError{code=_UNKNOWN_PARTITION,val=-190,str="StoreOffsets failed: Local: Unknown partition"}</msg>
<status status="FAIL" starttime="20220206 19:24:20.943" endtime="20220206 19:24:20.944"/>
</kw>
<status status="PASS" starttime="20220206 19:24:20.943" endtime="20220206 19:24:20.944"/>
</kw>
<kw name="Assign To Topic Partition" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<arg>${tp}</arg>
<doc>Assign a list of TopicPartitions.</doc>
<status status="PASS" starttime="20220206 19:24:20.944" endtime="20220206 19:24:20.944"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>5sec</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:25.945" level="INFO">Slept 5 seconds</msg>
<status status="PASS" starttime="20220206 19:24:20.945" endtime="20220206 19:24:25.945"/>
</kw>
<kw name="Store Offsets" library="ConfluentKafkaLibrary">
<arg>group_id=${group_id}</arg>
<arg>offsets=${offsets}</arg>
<doc>Store offsets for a message or a list of offsets.</doc>
<status status="PASS" starttime="20220206 19:24:25.946" endtime="20220206 19:24:25.946"/>
</kw>
<status status="PASS" starttime="20220206 19:24:20.940" endtime="20220206 19:24:25.946"/>
</test>
<status status="PASS" starttime="20220206 19:23:36.605" endtime="20220206 19:24:25.947"/>
</suite>
<suite id="s1-s2" name="Test Adminclient" source="/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples/test_adminclient.robot">
<test id="s1-s2-t1" name="AdminClient Topic Creation">
<kw name="Create List" library="BuiltIn">
<var>${topic_names}</var>
<arg>admintesting1</arg>
<arg>admintesting2</arg>
<arg>admintesting3</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:24:25.953" level="INFO">${topic_names} = ['admintesting1', 'admintesting2', 'admintesting3']</msg>
<status status="PASS" starttime="20220206 19:24:25.952" endtime="20220206 19:24:25.953"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${topics}</var>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:24:25.953" level="INFO">${topics} = []</msg>
<status status="PASS" starttime="20220206 19:24:25.953" endtime="20220206 19:24:25.953"/>
</kw>
<for flavor="IN">
<var>${topic}</var>
<value>@{topic_names}</value>
<iter>
<var name="${topic}">admintesting1</var>
<kw name="New Topic" library="ConfluentKafkaLibrary">
<var>${topic}</var>
<arg>${topic}</arg>
<arg>num_partitions=${1}</arg>
<arg>replication_factor=${1}</arg>
<doc>Instantiate a NewTopic object. Specifies per-topic settings for passing to AdminClient.create_topics().
- ``topic`` (str): Topic name
Note: In a multi-cluster production scenario, it is more typical to use a
replication_factor of 3 for durability.</doc>
<msg timestamp="20220206 19:24:25.955" level="INFO">${topic} = NewTopic(topic=admintesting1,num_partitions=1)</msg>
<status status="PASS" starttime="20220206 19:24:25.954" endtime="20220206 19:24:25.955"/>
</kw>
<kw name="Append To List" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Adds ``values`` to the end of ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:25.955" endtime="20220206 19:24:25.955"/>
</kw>
<status status="PASS" starttime="20220206 19:24:25.954" endtime="20220206 19:24:25.955"/>
</iter>
<iter>
<var name="${topic}">admintesting2</var>
<kw name="New Topic" library="ConfluentKafkaLibrary">
<var>${topic}</var>
<arg>${topic}</arg>
<arg>num_partitions=${1}</arg>
<arg>replication_factor=${1}</arg>
<doc>Instantiate a NewTopic object. Specifies per-topic settings for passing to AdminClient.create_topics().
- ``topic`` (str): Topic name
Note: In a multi-cluster production scenario, it is more typical to use a
replication_factor of 3 for durability.</doc>
<msg timestamp="20220206 19:24:25.956" level="INFO">${topic} = NewTopic(topic=admintesting2,num_partitions=1)</msg>
<status status="PASS" starttime="20220206 19:24:25.955" endtime="20220206 19:24:25.956"/>
</kw>
<kw name="Append To List" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Adds ``values`` to the end of ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:25.956" endtime="20220206 19:24:25.956"/>
</kw>
<status status="PASS" starttime="20220206 19:24:25.955" endtime="20220206 19:24:25.956"/>
</iter>
<iter>
<var name="${topic}">admintesting3</var>
<kw name="New Topic" library="ConfluentKafkaLibrary">
<var>${topic}</var>
<arg>${topic}</arg>
<arg>num_partitions=${1}</arg>
<arg>replication_factor=${1}</arg>
<doc>Instantiate a NewTopic object. Specifies per-topic settings for passing to AdminClient.create_topics().
- ``topic`` (str): Topic name
Note: In a multi-cluster production scenario, it is more typical to use a
replication_factor of 3 for durability.</doc>
<msg timestamp="20220206 19:24:25.957" level="INFO">${topic} = NewTopic(topic=admintesting3,num_partitions=1)</msg>
<status status="PASS" starttime="20220206 19:24:25.956" endtime="20220206 19:24:25.957"/>
</kw>
<kw name="Append To List" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Adds ``values`` to the end of ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:25.957" endtime="20220206 19:24:25.958"/>
</kw>
<status status="PASS" starttime="20220206 19:24:25.956" endtime="20220206 19:24:25.958"/>
</iter>
<status status="PASS" starttime="20220206 19:24:25.953" endtime="20220206 19:24:25.958"/>
</for>
<kw name="Create Admin Client" library="ConfluentKafkaLibrary">
<var>${admin_client_id}</var>
<msg timestamp="20220206 19:24:25.958" level="INFO">${admin_client_id} = 67e93e89-938c-42bd-a420-4c14d630e638</msg>
<status status="PASS" starttime="20220206 19:24:25.958" endtime="20220206 19:24:25.958"/>
</kw>
<kw name="Create Topics" library="ConfluentKafkaLibrary">
<arg>group_id=${admin_client_id}</arg>
<arg>new_topics=${topics}</arg>
<doc>Create one or more new topics and wait for each one to finish.
- ``new_topics`` (list(NewTopic) or NewTopic): A list of specifications (NewTopic)
    or a single instance for the topics that should be created.</doc>
<msg timestamp="20220206 19:24:26.035" level="INFO">Topic admintesting1 created
Topic admintesting2 created
Topic admintesting3 created</msg>
<status status="PASS" starttime="20220206 19:24:25.958" endtime="20220206 19:24:26.035"/>
</kw>
<kw name="List Topics" library="ConfluentKafkaLibrary">
<var>${topics}</var>
<arg>${admin_client_id}</arg>
<doc>Request Metadata from cluster. Could be executed with consumer or producer group_id too.
- ``topic`` (str):  If specified, only request info about this topic, else return for all topics in cluster.
Default: `None`.
- ``group_id`` (str): *required* id of the created consumer or producer.</doc>
<msg timestamp="20220206 19:24:26.039" level="INFO">${topics} = {'test': TopicMetadata(test, 1 partitions), 'topicwithoutvaluee': TopicMetadata(topicwithoutvaluee, 1 partitions), '_schemas': TopicMetadata(_schemas, 1 partitions), 'admintesting2': TopicMetadata(adm...</msg>
<status status="PASS" starttime="20220206 19:24:26.035" endtime="20220206 19:24:26.039"/>
</kw>
<for flavor="IN">
<var>${topic}</var>
<value>@{topic_names}</value>
<iter>
<var name="${topic}">admintesting1</var>
<kw name="List Should Contain Value" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Fails if the ``value`` is not found from ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:26.039" endtime="20220206 19:24:26.039"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.039" endtime="20220206 19:24:26.039"/>
</iter>
<iter>
<var name="${topic}">admintesting2</var>
<kw name="List Should Contain Value" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Fails if the ``value`` is not found from ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:26.040" endtime="20220206 19:24:26.040"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.040" endtime="20220206 19:24:26.040"/>
</iter>
<iter>
<var name="${topic}">admintesting3</var>
<kw name="List Should Contain Value" library="Collections">
<arg>${topics}</arg>
<arg>${topic}</arg>
<doc>Fails if the ``value`` is not found from ``list``.</doc>
<status status="PASS" starttime="20220206 19:24:26.040" endtime="20220206 19:24:26.040"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.040" endtime="20220206 19:24:26.040"/>
</iter>
<status status="PASS" starttime="20220206 19:24:26.039" endtime="20220206 19:24:26.040"/>
</for>
<kw name="Delete Topics" library="ConfluentKafkaLibrary" type="TEARDOWN">
<arg>${admin_client_id}</arg>
<arg>${topic_names}</arg>
<msg timestamp="20220206 19:24:26.121" level="INFO">Topic admintesting1 deleted
Topic admintesting2 deleted
Topic admintesting3 deleted</msg>
<status status="PASS" starttime="20220206 19:24:26.041" endtime="20220206 19:24:26.121"/>
</kw>
<status status="PASS" starttime="20220206 19:24:25.952" endtime="20220206 19:24:26.122"/>
</test>
<test id="s1-s2-t2" name="AdminClient List Groups">
<kw name="Create Admin Client" library="ConfluentKafkaLibrary">
<var>${admin_client_id}</var>
<msg timestamp="20220206 19:24:26.123" level="INFO">${admin_client_id} = 10c62b0b-121f-44fd-9a15-8421b83fc496</msg>
<status status="PASS" starttime="20220206 19:24:26.123" endtime="20220206 19:24:26.124"/>
</kw>
<kw name="List Groups" library="ConfluentKafkaLibrary">
<var>${groups}</var>
<arg>${admin_client_id}</arg>
<msg timestamp="20220206 19:24:26.153" level="INFO">${groups} = [GroupMetadata(2a6e559c-f267-4be3-b1c7-be0c371b2f8a), GroupMetadata(236b53e1-440f-4c22-a385-e0e55ab9992d), GroupMetadata(d94ed6b8-27f0-482a-9db6-d838b67318b9), GroupMetadata(6c6939e4-2603-4161-a8d7-82...</msg>
<status status="PASS" starttime="20220206 19:24:26.124" endtime="20220206 19:24:26.153"/>
</kw>
<kw name="Should Not Be Empty" library="BuiltIn">
<arg>${groups}</arg>
<doc>Verifies that the given item is not empty.</doc>
<msg timestamp="20220206 19:24:26.153" level="INFO">Length is 8</msg>
<status status="PASS" starttime="20220206 19:24:26.153" endtime="20220206 19:24:26.153"/>
</kw>
<doc>If you run this test as first switch to Should Be Empty keyword.</doc>
<status status="PASS" starttime="20220206 19:24:26.122" endtime="20220206 19:24:26.153"/>
</test>
<test id="s1-s2-t3" name="AdminClient New Partitions">
<kw name="Set Variable" library="BuiltIn">
<var>${topic_name}</var>
<arg>admin_testing_partition</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:26.155" level="INFO">${topic_name} = admin_testing_partition</msg>
<status status="PASS" starttime="20220206 19:24:26.155" endtime="20220206 19:24:26.155"/>
</kw>
<kw name="New Topic" library="ConfluentKafkaLibrary">
<var>${topic}</var>
<arg>${topic_name}</arg>
<arg>num_partitions=${1}</arg>
<arg>replication_factor=${1}</arg>
<doc>Instantiate a NewTopic object. Specifies per-topic settings for passing to AdminClient.create_topics().
- ``topic`` (str): Topic name
Note: In a multi-cluster production scenario, it is more typical to use a
replication_factor of 3 for durability.</doc>
<msg timestamp="20220206 19:24:26.157" level="INFO">${topic} = NewTopic(topic=admin_testing_partition,num_partitions=1)</msg>
<status status="PASS" starttime="20220206 19:24:26.156" endtime="20220206 19:24:26.157"/>
</kw>
<kw name="Create Admin Client" library="ConfluentKafkaLibrary">
<var>${admin_client_id}</var>
<msg timestamp="20220206 19:24:26.157" level="INFO">${admin_client_id} = 7966f03b-f007-428d-be45-e70e79528f87</msg>
<status status="PASS" starttime="20220206 19:24:26.157" endtime="20220206 19:24:26.157"/>
</kw>
<kw name="Create Topics" library="ConfluentKafkaLibrary">
<arg>group_id=${admin_client_id}</arg>
<arg>new_topics=${topic}</arg>
<doc>Create one or more new topics and wait for each one to finish.
- ``new_topics`` (list(NewTopic) or NewTopic): A list of specifications (NewTopic)
    or a single instance for the topics that should be created.</doc>
<msg timestamp="20220206 19:24:26.194" level="INFO">Topic admin_testing_partition created</msg>
<status status="PASS" starttime="20220206 19:24:26.157" endtime="20220206 19:24:26.195"/>
</kw>
<kw name="New Partitions" library="ConfluentKafkaLibrary">
<var>${new_parts}</var>
<arg>${topic_name}</arg>
<arg>new_total_count=${2}</arg>
<doc>Instantiate a NewPartitions object.
- ``topic`` (str): Topic name</doc>
<msg timestamp="20220206 19:24:26.196" level="INFO">${new_parts} = NewPartitions(topic=admin_testing_partition,new_total_count=2)</msg>
<status status="PASS" starttime="20220206 19:24:26.195" endtime="20220206 19:24:26.196"/>
</kw>
<kw name="Create Partitions" library="ConfluentKafkaLibrary">
<arg>group_id=${admin_client_id}</arg>
<arg>new_partitions=${new_parts}</arg>
<doc>Create additional partitions for the given topics.
- ``new_partitions``  (list(NewPartitions) or NewPartitions): New partitions to be created.</doc>
<msg timestamp="20220206 19:24:26.237" level="INFO">Additional partitions created for topic admin_testing_partition</msg>
<status status="PASS" starttime="20220206 19:24:26.196" endtime="20220206 19:24:26.237"/>
</kw>
<kw name="Delete Topics" library="ConfluentKafkaLibrary" type="TEARDOWN">
<arg>${admin_client_id}</arg>
<arg>${topic_name}</arg>
<msg timestamp="20220206 19:24:26.253" level="INFO">Topic admin_testing_partition deleted</msg>
<status status="PASS" starttime="20220206 19:24:26.237" endtime="20220206 19:24:26.253"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.154" endtime="20220206 19:24:26.253"/>
</test>
<test id="s1-s2-t4" name="AdminClient Describe Configs">
<kw name="Config Resource" library="ConfluentKafkaLibrary">
<var>${resource}</var>
<arg>${ADMIN_RESOURCE_BROKER}</arg>
<arg>1</arg>
<doc>Represents a resource that has configuration, and (optionally) a collection of configuration properties
for that resource. Used by describe_configs() and alter_configs().
- ``restype`` (ConfigResource.Type): The resource type.
-  ``name`` (str): The resource name, which depends on the resource type. For RESOURCE_BROKER,
    the resource name is the broker id.</doc>
<msg timestamp="20220206 19:24:26.255" level="INFO">${resource} = ConfigResource(Type.BROKER,1)</msg>
<status status="PASS" starttime="20220206 19:24:26.254" endtime="20220206 19:24:26.255"/>
</kw>
<kw name="Create Admin Client" library="ConfluentKafkaLibrary">
<var>${admin_client_id}</var>
<msg timestamp="20220206 19:24:26.256" level="INFO">${admin_client_id} = 8e8d89f4-fdb7-43f3-8f5e-20f146885c1c</msg>
<status status="PASS" starttime="20220206 19:24:26.255" endtime="20220206 19:24:26.256"/>
</kw>
<kw name="Describe Configs" library="ConfluentKafkaLibrary">
<var>${config}</var>
<arg>${admin_client_id}</arg>
<arg>${resource}</arg>
<doc>Get the configuration of the specified resources.
- ``resources``  (list(ConfigResource) or ConfigResource): Resources to get the configuration for.</doc>
<msg timestamp="20220206 19:24:26.307" level="INFO">${config} = {'advertised.host.name': ConfigEntry(advertised.host.name="None"), 'log.cleaner.min.compaction.lag.ms': ConfigEntry(log.cleaner.min.compaction.lag.ms="0"), 'metric.reporters': ConfigEntry(metric.repor...</msg>
<status status="PASS" starttime="20220206 19:24:26.256" endtime="20220206 19:24:26.307"/>
</kw>
<kw name="Should Not Be Empty" library="BuiltIn">
<arg>${config}</arg>
<doc>Verifies that the given item is not empty.</doc>
<msg timestamp="20220206 19:24:26.307" level="INFO">Length is 190</msg>
<status status="PASS" starttime="20220206 19:24:26.307" endtime="20220206 19:24:26.307"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${name}</var>
<arg>${config['offsets.commit.timeout.ms'].name}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:26.308" level="INFO">${name} = offsets.commit.timeout.ms</msg>
<status status="PASS" starttime="20220206 19:24:26.307" endtime="20220206 19:24:26.308"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${value}</var>
<arg>${config['offsets.commit.timeout.ms'].value}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:26.309" level="INFO">${value} = 5000</msg>
<status status="PASS" starttime="20220206 19:24:26.308" endtime="20220206 19:24:26.309"/>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<arg>${name}</arg>
<arg>offsets.commit.timeout.ms</arg>
<doc>Fails if objects are unequal after converting them to strings.</doc>
<status status="PASS" starttime="20220206 19:24:26.309" endtime="20220206 19:24:26.309"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${value}</arg>
<arg>${5000}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:26.310" level="INFO">Argument types are:
&lt;type 'unicode'&gt;
&lt;class 'int'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:26.309" endtime="20220206 19:24:26.310"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.254" endtime="20220206 19:24:26.310"/>
</test>
<test id="s1-s2-t5" name="AdminClient Alter Configs">
<kw name="Create Dictionary" library="BuiltIn">
<var>${data}</var>
<arg>log.retention.ms=${54321}</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:26.311" level="INFO">${data} = {'log.retention.ms': 54321}</msg>
<status status="PASS" starttime="20220206 19:24:26.311" endtime="20220206 19:24:26.311"/>
</kw>
<kw name="Convert To Dictionary" library="Collections">
<var>${data}</var>
<arg>${data}</arg>
<doc>Converts the given ``item`` to a Python ``dict`` type.</doc>
<msg timestamp="20220206 19:24:26.312" level="INFO">${data} = {'log.retention.ms': 54321}</msg>
<status status="PASS" starttime="20220206 19:24:26.312" endtime="20220206 19:24:26.312"/>
</kw>
<kw name="Config Resource" library="ConfluentKafkaLibrary">
<var>${resource}</var>
<arg>${ADMIN_RESOURCE_BROKER}</arg>
<arg>1</arg>
<arg>set_config=${data}</arg>
<doc>Represents a resource that has configuration, and (optionally) a collection of configuration properties
for that resource. Used by describe_configs() and alter_configs().
- ``restype`` (ConfigResource.Type): The resource type.
-  ``name`` (str): The resource name, which depends on the resource type. For RESOURCE_BROKER,
    the resource name is the broker id.</doc>
<msg timestamp="20220206 19:24:26.312" level="INFO">${resource} = ConfigResource(Type.BROKER,1)</msg>
<status status="PASS" starttime="20220206 19:24:26.312" endtime="20220206 19:24:26.312"/>
</kw>
<kw name="Create Admin Client" library="ConfluentKafkaLibrary">
<var>${admin_client_id}</var>
<msg timestamp="20220206 19:24:26.313" level="INFO">${admin_client_id} = 26bfe153-a906-44b3-9d27-5e68396b94d3</msg>
<status status="PASS" starttime="20220206 19:24:26.312" endtime="20220206 19:24:26.313"/>
</kw>
<kw name="Alter Configs" library="ConfluentKafkaLibrary">
<arg>${admin_client_id}</arg>
<arg>${resource}</arg>
<doc>Update configuration properties for the specified resources.
- ``resources``  (list(ConfigResource) or ConfigResource): Resources to update configuration of.</doc>
<msg timestamp="20220206 19:24:26.355" level="INFO">ConfigResource(Type.BROKER,1) configuration successfully altered</msg>
<status status="PASS" starttime="20220206 19:24:26.313" endtime="20220206 19:24:26.355"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1s</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:27.356" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:26.356" endtime="20220206 19:24:27.356"/>
</kw>
<kw name="Describe Configs" library="ConfluentKafkaLibrary">
<var>${config}</var>
<arg>${admin_client_id}</arg>
<arg>${resource}</arg>
<doc>Get the configuration of the specified resources.
- ``resources``  (list(ConfigResource) or ConfigResource): Resources to get the configuration for.</doc>
<msg timestamp="20220206 19:24:27.370" level="INFO">${config} = {'advertised.host.name': ConfigEntry(advertised.host.name="None"), 'log.cleaner.min.compaction.lag.ms': ConfigEntry(log.cleaner.min.compaction.lag.ms="0"), 'metric.reporters': ConfigEntry(metric.repor...</msg>
<status status="PASS" starttime="20220206 19:24:27.356" endtime="20220206 19:24:27.370"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${54321}</arg>
<arg>${config['log.retention.ms'].value}</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:27.371" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:27.370" endtime="20220206 19:24:27.371"/>
</kw>
<status status="PASS" starttime="20220206 19:24:26.310" endtime="20220206 19:24:27.372"/>
</test>
<status status="PASS" starttime="20220206 19:24:25.949" endtime="20220206 19:24:27.372"/>
</suite>
<suite id="s1-s3" name="Test Avro" source="/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples/test_avro.robot">
<kw name="Starting Test" type="SETUP">
<kw name="Set Suite Variable" library="BuiltIn">
<arg>@{TEST_TOPIC}</arg>
<arg>avro_testing1</arg>
<arg>avro_testing2</arg>
<arg>avro_testing3</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:24:27.381" level="INFO">@{TEST_TOPIC} = [ avro_testing1 | avro_testing2 | avro_testing3 ]</msg>
<status status="PASS" starttime="20220206 19:24:27.380" endtime="20220206 19:24:27.381"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${KEY}</arg>
<arg>568a68fd-2785-44cc-8997-1295c3755d28</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:24:27.382" level="INFO">${KEY} = 568a68fd-2785-44cc-8997-1295c3755d28</msg>
<status status="PASS" starttime="20220206 19:24:27.382" endtime="20220206 19:24:27.382"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>&amp;{KEY_FOR_SCHEMA}</arg>
<arg>name=testkey</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:24:27.383" level="INFO">&amp;{KEY_FOR_SCHEMA} = { name=testkey }</msg>
<status status="PASS" starttime="20220206 19:24:27.382" endtime="20220206 19:24:27.383"/>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<var>${value}</var>
<arg>name=Robot</arg>
<arg>number=${10}</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:27.384" level="INFO">${value} = {'name': 'Robot', 'number': 10}</msg>
<status status="PASS" starttime="20220206 19:24:27.383" endtime="20220206 19:24:27.384"/>
</kw>
<kw name="Create List" library="BuiltIn">
<var>${data}</var>
<arg>${value}</arg>
<doc>Returns a list containing given items.</doc>
<msg timestamp="20220206 19:24:27.384" level="INFO">${data} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:27.384" endtime="20220206 19:24:27.384"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${data}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:24:27.385" level="INFO">${TEST_DATA} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:27.384" endtime="20220206 19:24:27.385"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${value_schema}</var>
<arg>{"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:27.386" level="INFO">${value_schema} = {"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</msg>
<status status="PASS" starttime="20220206 19:24:27.385" endtime="20220206 19:24:27.386"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${key_schema}</var>
<arg>{"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"}]}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:27.386" level="INFO">${key_schema} = {"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"}]}</msg>
<status status="PASS" starttime="20220206 19:24:27.386" endtime="20220206 19:24:27.386"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<arg>value_schema=${value_schema}</arg>
<arg>key_schema=${key_schema}</arg>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:24:27.387" level="INFO">${producer_id} = 041f32c9-a243-4694-b3c5-0b997101a65c</msg>
<status status="PASS" starttime="20220206 19:24:27.386" endtime="20220206 19:24:27.387"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing1</arg>
<arg>partition=${0}</arg>
<arg>value=${value}</arg>
<arg>key=${KEY_FOR_SCHEMA}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:27.387" endtime="20220206 19:24:27.772"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:27.875" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:27.773" endtime="20220206 19:24:27.875"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:27.875" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:27.875" endtime="20220206 19:24:27.875"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:27.876" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:27.876" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:27.875" endtime="20220206 19:24:27.876"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:27.773" endtime="20220206 19:24:27.877"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:28.480" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:28.378" endtime="20220206 19:24:28.480"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:28.481" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:28.480" endtime="20220206 19:24:28.481"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:28.481" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:28.482" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:28.481" endtime="20220206 19:24:28.482"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:28.377" endtime="20220206 19:24:28.483"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:29.086" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:28.984" endtime="20220206 19:24:29.086"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:29.086" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:29.086" endtime="20220206 19:24:29.086"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:29.087" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:29.087" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:29.087" endtime="20220206 19:24:29.087"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:28.983" endtime="20220206 19:24:29.088"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:29.589" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:29.589" endtime="20220206 19:24:29.589"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:29.589" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:29.589" endtime="20220206 19:24:29.589"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:29.590" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:29.590" endtime="20220206 19:24:29.590"/>
</kw>
<status status="PASS" starttime="20220206 19:24:29.588" endtime="20220206 19:24:29.590"/>
</kw>
<status status="PASS" starttime="20220206 19:24:27.772" endtime="20220206 19:24:29.590"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing2</arg>
<arg>partition=${0}</arg>
<arg>value=${value}</arg>
<arg>key=${KEY_FOR_SCHEMA}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:29.590" endtime="20220206 19:24:29.626"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:29.728" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:29.627" endtime="20220206 19:24:29.728"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:29.728" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:29.728" endtime="20220206 19:24:29.728"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:29.729" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:29.729" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:29.728" endtime="20220206 19:24:29.729"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:29.626" endtime="20220206 19:24:29.730"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:30.332" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:30.231" endtime="20220206 19:24:30.332"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:30.333" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:30.332" endtime="20220206 19:24:30.333"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:30.333" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:30.334" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:30.333" endtime="20220206 19:24:30.334"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:30.230" endtime="20220206 19:24:30.334"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:30.937" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:30.835" endtime="20220206 19:24:30.937"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:30.937" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:30.937" endtime="20220206 19:24:30.937"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:30.938" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:30.938" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:30.937" endtime="20220206 19:24:30.938"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:30.835" endtime="20220206 19:24:30.939"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:31.441" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:31.441" endtime="20220206 19:24:31.441"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:31.441" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:31.441" endtime="20220206 19:24:31.441"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:31.442" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:31.442" endtime="20220206 19:24:31.442"/>
</kw>
<status status="PASS" starttime="20220206 19:24:31.439" endtime="20220206 19:24:31.442"/>
</kw>
<status status="PASS" starttime="20220206 19:24:29.626" endtime="20220206 19:24:31.442"/>
</kw>
<kw name="Start Consumer Threaded" library="ConfluentKafkaLibrary">
<var>${thread}</var>
<arg>topics=${TEST_TOPIC}</arg>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<arg>auto_offset_reset=latest</arg>
<doc>Run consumer in daemon thread and store data from topics. To read and work with this
   collected data use keyword `Get Messages From Thread`.
   Could be used at the Test setup or in each test.
   This is useful when you are reading always the same topics and you don't want to create
   consumer in each test to poll data. You can create as many consumers in the Test setup
   as you want and then in test just read data with `Get Messages From Thread` keyword.
- ``topics`` (list): List of topics for subscription.
- ``group_id`` (str or uuid.uuid4() if not set) : name of the consumer group to join for
    dynamic partition assignment (if enabled), and to use for fetching and
    committing offsets. If None, unique string is generated  (via uuid.uuid4())
    and offset commits are disabled. Default: `None`.</doc>
<msg timestamp="20220206 19:24:41.470" level="INFO">${thread} = &lt;GetMessagesThread(Thread-2, started daemon 139781623076608)&gt;</msg>
<status status="PASS" starttime="20220206 19:24:31.442" endtime="20220206 19:24:41.470"/>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<arg>${MAIN_THREAD}</arg>
<arg>${thread}</arg>
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<msg timestamp="20220206 19:24:41.472" level="INFO">${MAIN_THREAD} = &lt;GetMessagesThread(Thread-2, started daemon 139781623076608)&gt;</msg>
<status status="PASS" starttime="20220206 19:24:41.470" endtime="20220206 19:24:41.472"/>
</kw>
<status status="PASS" starttime="20220206 19:24:27.380" endtime="20220206 19:24:41.472"/>
</kw>
<test id="s1-s3-t1" name="Avro Producer With Schemas As String Argument">
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="SETUP">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:41.472" endtime="20220206 19:24:41.473"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${value_schema}</var>
<arg>{"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:41.473" level="INFO">${value_schema} = {"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</msg>
<status status="PASS" starttime="20220206 19:24:41.473" endtime="20220206 19:24:41.473"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${key_schema}</var>
<arg>{"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"}]}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:41.473" level="INFO">${key_schema} = {"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"}]}</msg>
<status status="PASS" starttime="20220206 19:24:41.473" endtime="20220206 19:24:41.473"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<arg>value_schema=${value_schema}</arg>
<arg>key_schema=${key_schema}</arg>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:24:41.475" level="INFO">${producer_id} = d68d3d06-90ce-4f2e-84dd-a10b90469513</msg>
<status status="PASS" starttime="20220206 19:24:41.473" endtime="20220206 19:24:41.475"/>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<var>${value}</var>
<arg>name=Robot</arg>
<arg>number=${10}</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:41.476" level="INFO">${value} = {'name': 'Robot', 'number': 10}</msg>
<status status="PASS" starttime="20220206 19:24:41.475" endtime="20220206 19:24:41.476"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing1</arg>
<arg>partition=${0}</arg>
<arg>value=${value}</arg>
<arg>key=${KEY_FOR_SCHEMA}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:41.477" endtime="20220206 19:24:41.493"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:41.595" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:41.493" endtime="20220206 19:24:41.595"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:41.596" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:41.595" endtime="20220206 19:24:41.596"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:41.596" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:41.596" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:41.596" endtime="20220206 19:24:41.596"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:41.493" endtime="20220206 19:24:41.597"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:42.200" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:42.098" endtime="20220206 19:24:42.200"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:42.200" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:42.200" endtime="20220206 19:24:42.200"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:42.201" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:42.201" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:42.200" endtime="20220206 19:24:42.201"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:42.097" endtime="20220206 19:24:42.202"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:42.703" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:42.703" endtime="20220206 19:24:42.703"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:42.703" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:42.703" endtime="20220206 19:24:42.703"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:42.704" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:42.704" endtime="20220206 19:24:42.704"/>
</kw>
<status status="PASS" starttime="20220206 19:24:42.702" endtime="20220206 19:24:42.704"/>
</kw>
<status status="PASS" starttime="20220206 19:24:41.493" endtime="20220206 19:24:42.704"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1s</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:43.704" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:42.704" endtime="20220206 19:24:43.705"/>
</kw>
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${consumer_group_id}</var>
<arg>auto_offset_reset=earliest</arg>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:24:43.706" level="INFO">${consumer_group_id} = 70355a36-0d34-4394-a199-86172c439b34</msg>
<status status="PASS" starttime="20220206 19:24:43.705" endtime="20220206 19:24:43.706"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${consumer_group_id}</arg>
<arg>topics=avro_testing1</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:24:43.706" endtime="20220206 19:24:43.707"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${consumer_group_id}</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:43.828" level="WARN">Fast avro failed for schema with id 1, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:43.833" level="WARN">Fast avro failed for schema with id 2, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:43.833" level="INFO">${messages} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:43.707" endtime="20220206 19:24:43.833"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${messages}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:43.833" endtime="20220206 19:24:43.834"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages}</var>
<arg>${MAIN_THREAD}</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:43.834" level="INFO">${thread_messages} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:43.834" endtime="20220206 19:24:43.834"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${thread_messages}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:43.834" endtime="20220206 19:24:43.834"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${consumer_group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:24:43.835" endtime="20220206 19:24:43.835"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:24:43.835" endtime="20220206 19:24:43.840"/>
</kw>
<status status="PASS" starttime="20220206 19:24:43.835" endtime="20220206 19:24:43.840"/>
</kw>
<status status="PASS" starttime="20220206 19:24:41.472" endtime="20220206 19:24:43.840"/>
</test>
<test id="s1-s3-t2" name="Avro Producer With Path To Schemas">
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="SETUP">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:43.841" endtime="20220206 19:24:43.842"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${value_schema_file_path}</var>
<arg>examples/schema/producer/ValueSchema.avsc</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:43.842" level="INFO">${value_schema_file_path} = examples/schema/producer/ValueSchema.avsc</msg>
<status status="PASS" starttime="20220206 19:24:43.842" endtime="20220206 19:24:43.842"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${key_schema_file_path}</var>
<arg>examples/schema/producer/KeySchema.avsc</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:43.842" level="INFO">${key_schema_file_path} = examples/schema/producer/KeySchema.avsc</msg>
<status status="PASS" starttime="20220206 19:24:43.842" endtime="20220206 19:24:43.842"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<arg>value_schema=${value_schema_file_path}</arg>
<arg>key_schema=${key_schema_file_path}</arg>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:24:43.843" level="INFO">${producer_id} = a7896adc-cfe2-4b89-b388-e2cab9bc441a</msg>
<status status="PASS" starttime="20220206 19:24:43.842" endtime="20220206 19:24:43.843"/>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<var>${value}</var>
<arg>name=Robot</arg>
<arg>number=${10}</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:43.845" level="INFO">${value} = {'name': 'Robot', 'number': 10}</msg>
<status status="PASS" starttime="20220206 19:24:43.844" endtime="20220206 19:24:43.845"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing2</arg>
<arg>partition=${0}</arg>
<arg>value=${value}</arg>
<arg>key=${KEY_FOR_SCHEMA}</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:43.845" endtime="20220206 19:24:43.858"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:43.960" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:43.859" endtime="20220206 19:24:43.960"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:43.961" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:43.960" endtime="20220206 19:24:43.961"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:43.961" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:43.961" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:43.961" endtime="20220206 19:24:43.961"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:43.858" endtime="20220206 19:24:43.962"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:44.564" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:44.463" endtime="20220206 19:24:44.564"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:44.565" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:44.564" endtime="20220206 19:24:44.565"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:44.565" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:44.565" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:44.565" endtime="20220206 19:24:44.565"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:44.462" endtime="20220206 19:24:44.566"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:45.067" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:45.067" endtime="20220206 19:24:45.067"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:45.068" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:45.068" endtime="20220206 19:24:45.068"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:45.068" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:45.068" endtime="20220206 19:24:45.068"/>
</kw>
<status status="PASS" starttime="20220206 19:24:45.066" endtime="20220206 19:24:45.068"/>
</kw>
<status status="PASS" starttime="20220206 19:24:43.858" endtime="20220206 19:24:45.068"/>
</kw>
<kw name="Sleep" library="BuiltIn">
<arg>1s</arg>
<doc>Pauses the test executed for the given time.</doc>
<msg timestamp="20220206 19:24:46.069" level="INFO">Slept 1 second</msg>
<status status="PASS" starttime="20220206 19:24:45.068" endtime="20220206 19:24:46.069"/>
</kw>
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${consumer_group_id}</var>
<arg>auto_offset_reset=earliest</arg>
<arg>schema_registry_url=http://127.0.0.1:8081</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:24:46.070" level="INFO">${consumer_group_id} = bfd1bb42-c656-4787-88d1-f20c714c6417</msg>
<status status="PASS" starttime="20220206 19:24:46.069" endtime="20220206 19:24:46.070"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${consumer_group_id}</arg>
<arg>topics=avro_testing2</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:24:46.070" endtime="20220206 19:24:46.071"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${consumer_group_id}</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:46.199" level="WARN">Fast avro failed for schema with id 1, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:46.206" level="WARN">Fast avro failed for schema with id 2, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:46.207" level="INFO">${messages} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:46.071" endtime="20220206 19:24:46.207"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${messages}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:46.207" endtime="20220206 19:24:46.208"/>
</kw>
<kw name="Get Messages From Thread" library="ConfluentKafkaLibrary">
<var>${thread_messages}</var>
<arg>${MAIN_THREAD}</arg>
<doc>Returns all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword
- ``decode_format`` (str) - If you need to decode data to specific format
    (See https://docs.python.org/3/library/codecs.html#standard-encodings). Default: None.</doc>
<msg timestamp="20220206 19:24:46.208" level="INFO">${thread_messages} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:46.208" endtime="20220206 19:24:46.208"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${TEST_DATA}</arg>
<arg>${thread_messages}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:46.208" endtime="20220206 19:24:46.208"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${consumer_group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:24:46.209" endtime="20220206 19:24:46.209"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:24:46.209" endtime="20220206 19:24:46.215"/>
</kw>
<status status="PASS" starttime="20220206 19:24:46.208" endtime="20220206 19:24:46.215"/>
</kw>
<status status="PASS" starttime="20220206 19:24:43.841" endtime="20220206 19:24:46.215"/>
</test>
<test id="s1-s3-t3" name="Avro Producer Consumer With Serializers">
<kw name="Clear Messages From Thread" library="ConfluentKafkaLibrary" type="SETUP">
<arg>${MAIN_THREAD}</arg>
<doc>Remove all records gathered from specific thread
- ``running_thread`` (Thread object) - thread which was executed with
    `Start Consumer Threaded` keyword</doc>
<status status="PASS" starttime="20220206 19:24:46.216" endtime="20220206 19:24:46.216"/>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<var>${schema_registry_conf}</var>
<arg>url=http://127.0.0.1:8081</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:46.216" level="INFO">${schema_registry_conf} = {'url': 'http://127.0.0.1:8081'}</msg>
<status status="PASS" starttime="20220206 19:24:46.216" endtime="20220206 19:24:46.216"/>
</kw>
<kw name="Get Schema Registry Client" library="ConfluentKafkaLibrary">
<var>${schema_registry_client}</var>
<arg>${schema_registry_conf}</arg>
<msg timestamp="20220206 19:24:46.217" level="INFO">${schema_registry_client} = &lt;confluent_kafka.schema_registry.schema_registry_client.SchemaRegistryClient object at 0x7f21eb1b00d0&gt;</msg>
<status status="PASS" starttime="20220206 19:24:46.216" endtime="20220206 19:24:46.217"/>
</kw>
<kw name="Set Variable" library="BuiltIn">
<var>${schema_str}</var>
<arg>{"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</arg>
<doc>Returns the given values which can then be assigned to a variables.</doc>
<msg timestamp="20220206 19:24:46.217" level="INFO">${schema_str} = {"namespace": "example.avro","type": "record","name": "User","fields": [{"name": "name","type": "string"},{"name": "number","type": ["int","null"]}]}</msg>
<status status="PASS" starttime="20220206 19:24:46.217" endtime="20220206 19:24:46.217"/>
</kw>
<kw name="Get Avro Serializer" library="ConfluentKafkaLibrary">
<var>${avro_serializer}</var>
<arg>${schema_str}</arg>
<arg>${schema_registry_client}</arg>
<msg timestamp="20220206 19:24:46.217" level="INFO">${avro_serializer} = &lt;confluent_kafka.schema_registry.avro.AvroSerializer object at 0x7f21e40f37c0&gt;</msg>
<status status="PASS" starttime="20220206 19:24:46.217" endtime="20220206 19:24:46.217"/>
</kw>
<kw name="Get Avro Deserializer" library="ConfluentKafkaLibrary">
<var>${avro_deserializer}</var>
<arg>${schema_str}</arg>
<arg>${schema_registry_client}</arg>
<msg timestamp="20220206 19:24:46.218" level="INFO">${avro_deserializer} = &lt;confluent_kafka.schema_registry.avro.AvroDeserializer object at 0x7f21e41534f0&gt;</msg>
<status status="PASS" starttime="20220206 19:24:46.218" endtime="20220206 19:24:46.218"/>
</kw>
<kw name="Get String Serializer" library="ConfluentKafkaLibrary">
<var>${string_serializer}</var>
<msg timestamp="20220206 19:24:46.218" level="INFO">${string_serializer} = &lt;confluent_kafka.serialization.StringSerializer object at 0x7f21e4120250&gt;</msg>
<status status="PASS" starttime="20220206 19:24:46.218" endtime="20220206 19:24:46.218"/>
</kw>
<kw name="Get String Deserializer" library="ConfluentKafkaLibrary">
<var>${string_deserializer}</var>
<msg timestamp="20220206 19:24:46.218" level="INFO">${string_deserializer} = &lt;confluent_kafka.serialization.StringDeserializer object at 0x7f21e4120c70&gt;</msg>
<status status="PASS" starttime="20220206 19:24:46.218" endtime="20220206 19:24:46.218"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<arg>key_serializer=${string_serializer}</arg>
<arg>value_serializer=${avro_serializer}</arg>
<arg>legacy=${False}</arg>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<msg timestamp="20220206 19:24:46.220" level="INFO">${producer_id} = 9d21b600-d690-4ab1-b77d-18362cbbaa45</msg>
<status status="PASS" starttime="20220206 19:24:46.218" endtime="20220206 19:24:46.220"/>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<var>${value}</var>
<arg>name=Robot</arg>
<arg>number=${10}</arg>
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<msg timestamp="20220206 19:24:46.221" level="INFO">${value} = {'name': 'Robot', 'number': 10}</msg>
<status status="PASS" starttime="20220206 19:24:46.220" endtime="20220206 19:24:46.221"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing3</arg>
<arg>partition=${0}</arg>
<arg>value=${value}</arg>
<arg>key=568a68fd-2785-44cc-8997-1295c3755d28</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:46.221" endtime="20220206 19:24:46.243"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:46.345" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:46.244" endtime="20220206 19:24:46.345"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:46.346" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:46.345" endtime="20220206 19:24:46.346"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:46.346" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:46.346" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:46.346" endtime="20220206 19:24:46.346"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:46.243" endtime="20220206 19:24:46.347"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:46.950" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:46.848" endtime="20220206 19:24:46.950"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:46.950" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:46.950" endtime="20220206 19:24:46.950"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:46.951" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:46.951" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:46.950" endtime="20220206 19:24:46.951"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:46.847" endtime="20220206 19:24:46.951"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:47.554" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:47.452" endtime="20220206 19:24:47.554"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:47.555" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:47.554" endtime="20220206 19:24:47.555"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:47.555" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:47.555" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:47.555" endtime="20220206 19:24:47.555"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:47.452" endtime="20220206 19:24:47.556"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:48.158" level="INFO">${count} = 1</msg>
<status status="PASS" starttime="20220206 19:24:48.057" endtime="20220206 19:24:48.158"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:48.158" level="INFO">Reaming messages to be delivered: 1</msg>
<status status="PASS" starttime="20220206 19:24:48.158" endtime="20220206 19:24:48.158"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:48.159" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<msg timestamp="20220206 19:24:48.159" level="FAIL">1 != 0</msg>
<status status="FAIL" starttime="20220206 19:24:48.159" endtime="20220206 19:24:48.159"/>
</kw>
<status status="FAIL" starttime="20220206 19:24:48.056" endtime="20220206 19:24:48.160"/>
</kw>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:48.661" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:48.661" endtime="20220206 19:24:48.661"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:48.662" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:48.662" endtime="20220206 19:24:48.662"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:48.662" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:48.662" endtime="20220206 19:24:48.662"/>
</kw>
<status status="PASS" starttime="20220206 19:24:48.660" endtime="20220206 19:24:48.662"/>
</kw>
<status status="PASS" starttime="20220206 19:24:46.243" endtime="20220206 19:24:48.662"/>
</kw>
<kw name="Create Consumer" library="ConfluentKafkaLibrary">
<var>${consumer_group_id}</var>
<arg>auto_offset_reset=latest</arg>
<arg>key_deserializer=${string_deserializer}</arg>
<arg>value_deserializer=${avro_deserializer}</arg>
<arg>legacy=${False}</arg>
<doc>Create Kafka Consumer and returns its `group_id` as string.</doc>
<msg timestamp="20220206 19:24:48.664" level="INFO">${consumer_group_id} = 429aaac5-9a8b-4279-9312-47fee4ca9630</msg>
<status status="PASS" starttime="20220206 19:24:48.663" endtime="20220206 19:24:48.664"/>
</kw>
<kw name="Subscribe Topic" library="ConfluentKafkaLibrary">
<arg>group_id=${consumer_group_id}</arg>
<arg>topics=avro_testing3</arg>
<doc>Subscribe to a list of topics, or a topic regex pattern.
   https://docs.confluent.io/current/clients/confluent-kafka-python/#confluent_kafka.Consumer.subscribe</doc>
<status status="PASS" starttime="20220206 19:24:48.664" endtime="20220206 19:24:48.665"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<arg>group_id=${consumer_group_id}</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<status status="PASS" starttime="20220206 19:24:48.665" endtime="20220206 19:24:58.668"/>
</kw>
<kw name="Produce" library="ConfluentKafkaLibrary">
<arg>group_id=${producer_id}</arg>
<arg>topic=avro_testing3</arg>
<arg>value=${value}</arg>
<arg>partition=${0}</arg>
<arg>key=568a68fd-2785-44cc-8997-1295c3755d28</arg>
<doc>Produce message to topic asynchronously to Kafka by encoding with specified or default avro schema.</doc>
<status status="PASS" starttime="20220206 19:24:58.668" endtime="20220206 19:24:58.669"/>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<arg>10x</arg>
<arg>0.5s</arg>
<arg>All Messages Are Delivered</arg>
<arg>${producer_id}</arg>
<doc>Runs the specified keyword and retries if it fails.</doc>
<kw name="All Messages Are Delivered">
<arg>${producer_id}</arg>
<kw name="Flush" library="ConfluentKafkaLibrary">
<var>${count}</var>
<arg>${producer_id}</arg>
<doc>Wait for all messages in the Producer queue to be delivered. Returns the number of messages still in queue.
This is a convenience method that calls poll() until len() is zero or the optional timeout elapses.
- `timeout` (real) : Optional timeout. Default: `0.1`.</doc>
<msg timestamp="20220206 19:24:58.673" level="INFO">${count} = 0</msg>
<status status="PASS" starttime="20220206 19:24:58.670" endtime="20220206 19:24:58.673"/>
</kw>
<kw name="Log" library="BuiltIn">
<arg>Reaming messages to be delivered: ${count}</arg>
<doc>Logs the given message with the given level.</doc>
<msg timestamp="20220206 19:24:58.673" level="INFO">Reaming messages to be delivered: 0</msg>
<status status="PASS" starttime="20220206 19:24:58.673" endtime="20220206 19:24:58.673"/>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<arg>${count}</arg>
<arg>0</arg>
<doc>Fails if objects are unequal after converting them to integers.</doc>
<msg timestamp="20220206 19:24:58.673" level="INFO">Argument types are:
&lt;class 'int'&gt;
&lt;type 'unicode'&gt;</msg>
<status status="PASS" starttime="20220206 19:24:58.673" endtime="20220206 19:24:58.673"/>
</kw>
<status status="PASS" starttime="20220206 19:24:58.669" endtime="20220206 19:24:58.674"/>
</kw>
<status status="PASS" starttime="20220206 19:24:58.669" endtime="20220206 19:24:58.674"/>
</kw>
<kw name="Poll" library="ConfluentKafkaLibrary">
<var>${messages}</var>
<arg>group_id=${consumer_group_id}</arg>
<doc>Fetch and return messages from assigned topics / partitions as list.
- ``timeout`` (int): Seconds spent waiting in poll if data is not available in the buffer.</doc>
<msg timestamp="20220206 19:24:58.674" level="INFO">${messages} = [{'name': 'Robot', 'number': 10}]</msg>
<status status="PASS" starttime="20220206 19:24:58.674" endtime="20220206 19:24:58.674"/>
</kw>
<kw name="Should Be Equal" library="BuiltIn">
<arg>${messages}</arg>
<arg>${TEST_DATA}</arg>
<doc>Fails if the given objects are unequal.</doc>
<status status="PASS" starttime="20220206 19:24:58.674" endtime="20220206 19:24:58.675"/>
</kw>
<kw name="Basic Teardown" type="TEARDOWN">
<arg>${consumer_group_id}</arg>
<kw name="Unsubscribe" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Unsubscribe of topics.</doc>
<status status="PASS" starttime="20220206 19:24:58.675" endtime="20220206 19:24:58.675"/>
</kw>
<kw name="Close Consumer" library="ConfluentKafkaLibrary">
<arg>${group_id}</arg>
<doc>Close down and terminate the Kafka Consumer.</doc>
<status status="PASS" starttime="20220206 19:24:58.675" endtime="20220206 19:24:58.680"/>
</kw>
<status status="PASS" starttime="20220206 19:24:58.675" endtime="20220206 19:24:58.681"/>
</kw>
<status status="PASS" starttime="20220206 19:24:46.215" endtime="20220206 19:24:58.681"/>
</test>
<status status="PASS" starttime="20220206 19:24:27.373" endtime="20220206 19:24:58.682"/>
</suite>
<suite id="s1-s4" name="Test Oauth" source="/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples/test_oauth.robot">
<test id="s1-s4-t1" name="Example Oauth">
<kw name="Skip" library="BuiltIn">
<doc>Skips the rest of the current test.</doc>
<msg timestamp="20220206 19:24:58.689" level="SKIP">Skipped with Skip keyword.</msg>
<status status="SKIP" starttime="20220206 19:24:58.689" endtime="20220206 19:24:58.689"/>
</kw>
<kw name="Get String Serializer" library="ConfluentKafkaLibrary">
<var>${string_serializer}</var>
<status status="NOT RUN" starttime="20220206 19:24:58.689" endtime="20220206 19:24:58.689"/>
</kw>
<kw name="Get String Serializer" library="ConfluentKafkaLibrary">
<var>${value_serializer}</var>
<status status="NOT RUN" starttime="20220206 19:24:58.689" endtime="20220206 19:24:58.690"/>
</kw>
<kw name="oauth_example.get_token">
<var>${fun}=</var>
<arg>configuration</arg>
<status status="NOT RUN" starttime="20220206 19:24:58.692" endtime="20220206 19:24:58.692"/>
</kw>
<kw name="Create Producer" library="ConfluentKafkaLibrary">
<var>${producer_id}</var>
<arg>key_serializer=${string_serializer}</arg>
<arg>value_serializer=${value_serializer}</arg>
<arg>legacy=${False}</arg>
<arg>security.protocol=sasl_plaintext</arg>
<arg>sasl.mechanisms=OAUTHBEARER</arg>
<arg>oauth_cb=${fun}</arg>
<doc>Create Kafka Producer and returns its `group_id` as string.
If `schema_registry_url` is used, Kafka Producer client which does avro schema
encoding to messages is created instead.</doc>
<status status="NOT RUN" starttime="20220206 19:24:58.692" endtime="20220206 19:24:58.692"/>
</kw>
<doc>Example of how to use OAUTH with library and call functools
via get_token function. For better handling there could be
some global variable which can be set inside of python lib.
Not executable right now, needs update env (issue #21).</doc>
<status status="SKIP" starttime="20220206 19:24:58.688" endtime="20220206 19:24:58.692">Skipped with Skip keyword.</status>
</test>
<status status="SKIP" starttime="20220206 19:24:58.684" endtime="20220206 19:24:58.693"/>
</suite>
<status status="PASS" starttime="20220206 19:23:36.587" endtime="20220206 19:24:58.694"/>
</suite>
<statistics>
<total>
<stat pass="19" fail="0" skip="1">All Tests</stat>
</total>
<tag>
</tag>
<suite>
<stat pass="19" fail="0" skip="1" id="s1" name="Examples">Examples</stat>
<stat pass="11" fail="0" skip="0" id="s1-s1" name="Test">Examples.Test</stat>
<stat pass="5" fail="0" skip="0" id="s1-s2" name="Test Adminclient">Examples.Test Adminclient</stat>
<stat pass="3" fail="0" skip="0" id="s1-s3" name="Test Avro">Examples.Test Avro</stat>
<stat pass="0" fail="0" skip="1" id="s1-s4" name="Test Oauth">Examples.Test Oauth</stat>
</suite>
</statistics>
<errors>
<msg timestamp="20220206 19:24:43.828" level="WARN">Fast avro failed for schema with id 1, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:43.833" level="WARN">Fast avro failed for schema with id 2, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:46.199" level="WARN">Fast avro failed for schema with id 1, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:46.206" level="WARN">Fast avro failed for schema with id 2, falling thru to standard avro</msg>
<msg timestamp="20220206 19:24:58.686" level="ERROR">Error in file '/home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary/examples/test_oauth.robot' on line 3: Importing library 'oauth_example' failed: ModuleNotFoundError: No module named 'oauth_example'
Traceback (most recent call last):
  None
PYTHONPATH:
  /home/runner/work/robotframework-ConfluentKafkaLibrary/robotframework-ConfluentKafkaLibrary
  /usr/lib/python38.zip
  /usr/lib/python3.8
  /usr/lib/python3.8/lib-dynload
  /home/runner/.local/lib/python3.8/site-packages
  /usr/local/lib/python3.8/dist-packages
  /usr/lib/python3/dist-packages</msg>
</errors>
</robot>
